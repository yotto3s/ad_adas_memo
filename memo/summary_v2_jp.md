# 設計段階での正常系仕様→ASIL-D異常系処理の導出（研究メモ）

## 1. 問題設定

全部をASIL-Dコア（lockstep等）で動かすのは過剰。正常系（ASIL-Bコア）と異常系（ASIL-Dコア）を非対称に分離して、**設計段階のSWアーキテクチャアーティファクト**（入力定義、出力仕様、チェックアルゴリズム、状態遷移設計）から異常系の最小限の処理を体系的に導出したい。

### 基本構想

- **正常系（ASIL-Bコア）**: アルゴリズム実行＋入出力の仕様チェック（plausibility、レンジチェック等）。バグがなければHW故障がない限り信頼できる出力を出す
- **異常系（ASIL-Dコア）**: 正常系の演算を再実行するのではなく、正常系のチェック機構自体がHW故障で無効化されてないかの確認＋最小限の独立出力検証に特化
- **設計段階で導出可能**: 正常系の実装完了を待たなくていい。SWアーキテクチャ設計段階の情報だけで異常系を確定できる

### ISO 26262との整合

ASIL分解 D = B(D) + B(D) で、intended function（正常系）とsafety mechanism（異常系）を非対称分離するアプローチ。ISO 26262 Part 6の範囲内。

---

## 2. ランダムハードウェア故障のモデル

対象はSWバグではなく、外部物理要因によるランダムHW故障。

### 2.1 SEU — メモリ・レジスタのビットフリップ

宇宙線（中性子）やアルファ粒子が記憶素子の電荷を反転させる。一過性で再書き込みで回復。

- **発生箇所**: SRAM、キャッシュ、CPUレジスタ、フリップフロップ
- **影響**: データ値の変化（1ビットまたはマルチビット）
- **発生率**: 車載用SRAMで数百〜数千 FIT/Mbit（FIT = 10⁹時間あたりの故障回数）
- **微細化の影響**: Qcritが下がってSEU感受性は増加傾向

3つの自然なマスキング: 論理マスキング（出力に伝播しない）、電気的マスキング（パルスが減衰）、時間的マスキング（ラッチタイミングに一致しない）。全部突破して初めてソフトエラーになる。

### 2.2 SET — 組み合わせ回路の一過性パルス

粒子衝突で組み合わせ回路（ALU、比較器等）に一過性パルスが出る。ラッチされるとSEUと同等。

- **発生箇所**: ALU、アドレスデコーダ、バスロジック
- **影響**: 演算結果の一時的誤り、アドレスの一時的化け
- **微細化・高周波数化で発生確率増加**

### 2.3 Stuck-at故障

物理的劣化（エレクトロマイグレーション、ホットキャリア劣化、NBTI等）で信号線やレジスタが0/1に固着。永続故障。

- **あらゆる論理素子、配線で発生**
- **時間経過で増加、自然回復しない**

### 2.4 ブリッジ故障

隣接信号線間の短絡。一方が他方の値に引きずられる。微細化で配線間距離が縮小しリスク増加。

### 2.5 EMI（電磁干渉）

車載環境特有（イグニッションノイズ、電力線ノイズ、外部無線等）。メモリやバスのデータを破壊。SEU類似のビットフリップだが、バースト的に複数ビット影響の可能性あり。車載では宇宙線よりEMIが支配的な場合も。

### 2.6 電源・クロック異常

電源変動やクロック乱れでセットアップ/ホールドタイム違反 → メタステーブルやデータ化け。Lockstepコアでは共通原因故障（CCF）になりうる。

### 2.7 今回の対象範囲

主に対象:
- **SEU/SET**: 最も頻度が高く、SWレベルで影響を分析しやすい
- **EMI起因のビットフリップ**: SEUと類似の影響モデルで扱える

対象外（別の安全メカニズムで対処）:
- Stuck-at/ブリッジ故障 → BIST、latent fault検出
- 電源/クロック異常 → 専用HW監視回路

---

## 3. 正常系の仕様チェックで検出できない故障パターン

### 3.1 実質問題にならないもの

- **許容範囲内の微小誤差**: 仕様の許容範囲はセンサノイズ等を考慮して設計してあるので、HW故障による微小変化が範囲内なら仕様が許容する不正確さの範囲
- **ノイズ耐性アルゴリズムへの入力変化**: 画像処理等は入力1ビット変化でアルゴリズム出力にほぼ影響なし。入力CRCは過剰検出でAvailabilityを損なう。出力側チェックで十分

### 3.2 異常系で対処が必要なもの

| パターン | 内容 | なぜ検出できないか |
|---|---|---|
| 入力データの破壊 | 入力がメモリ上で化けた状態で正常系に渡される | 正常系は化けた入力に対して「正しく」動作してしまう |
| 制御フローの化け | PCや分岐条件のビットフリップ | 仕様チェックは「実行された結果」しか見えない |
| チェック機構自体の故障 | 閾値/定数の化け、判定フラグの化け、チェックスキップ | 自分自身の故障は検出できない（自己参照問題） |

ASIL-Dコアの最も本質的な役割: **正常系の検証機構そのものが正しく動いていることの確認**

---

## 4. 異常系（ASIL-Dコア）の設計

### 4.1 アーキテクチャ

E-Gas由来の**3レベル監視パターン**を参考にする。E-Gas自体はドイツOEM（Audi, BMW, VW, Daimler, Porsche等）がエンジン制御向けに作った仕様だが、3レベルという構造原理はブレーキ・ステアリング等にも広く参照されている。これの1oo1D（1-out-of-1 with Diagnostics）をAD/ADASのSW安全監視に使う。

**出力データは正常系から直接アクチュエータへ出る。ASIL-Dコアは経由しない。** ASIL-Dコアはゲートキーパーではなく、正常系の健全性を監視して、異常時に独立HWシャットオフパスで遮断する。

```
[ASIL-Bコア（L1: 機能 + L2: 機能監視）]
1. 入力取得
2. アルゴリズム実行
3. 出力を直接アクチュエータへ
4. 出力の妥当性チェック（仕様チェック、plausibility等）
5. {チェック結果, チェック定数CRC, シグネチャ} をASIL-Dコアへ

[ASIL-Dコア（L2の一部 + L3: コントローラ監視）]
1. チェック結果が「正常」か確認
2. チェック定数CRCが起動時の値と一致するか（定数化け検出）
3. シグネチャが期待値と一致するか（制御フロー/チェック実行証明）
4. 最小限の独立出力plausibilityチェック（フォールバック）
5. 異常検出 → 独立シャットオフパスで遮断、安全状態へ
```

この設計だと出力データの転送中ビットフリップの問題が構造的に消える。ASIL-Dコアに送るのはチェック結果等の監視情報だけで、転送中保護は4.2の対処設計（符号化、シグネチャ、CRC）でカバー。

### 4.1.1 fail-safe vs fail-operational

今回は**fail-safe前提**（異常検出→安全状態へ遷移）。3レベル監視パターンと整合。

AD/ADASでは自動運転レベルによって前提が変わる:

- **fail-safeでOK**: ドライバーが介入できる（Level 0〜2、Level 3でも遷移時間確保できれば）。シャットオフか機能縮退で安全状態に到達。→ 今回の対象範囲
- **fail-operationalが必要**: ドライバーが即座に介入できない（Level 3以上、特にLevel 4/5）。高速道路で突然シャットオフは危険。異常後もMinimal Risk Maneuver（退避走行）の継続が必要

fail-operationalでも、今回の監視アーキテクチャ（仕様チェック構造→異常系モニタ導出、CRC/シグネチャ/符号化による検出、DC評価）はそのまま使える。異常検出後のアクションが「シャットオフ」→「代替制御への切り替え」に変わるだけ。ただし追加の設計考慮事項がある:

- **FTTIが厳しくなる可能性**: fail-safeはシャットオフまでの時間でいいが、fail-operationalでは代替制御切り替え＋安定出力までがFTTI内に収まる必要。検出レイテンシ要件が厳しくなると、シグネチャ検証をフレーム末まで待てず途中で部分検証が要るかもしれない
- **代替制御の入力確保**: 正常系が故障している状態でASIL-Dコアが代替制御するには、センサ入力に独立アクセスが必要。正常系経由の入力はもう信頼できない
- **異常の種類による切り替え戦略の分岐**: fail-safeはどの異常でも「止める」で済むが、fail-operationalでは何が壊れたかによって代替制御の内容が変わりうる。今回の検出メカニズムが「何が故障したか」の診断情報も提供できるかという追加要件

いずれも監視アーキテクチャの根幹は変えない。将来課題。

### 4.2 各故障パターンへの対処

**入力データの破壊**: 入力の種類で戦略を分ける。

- スカラー値（制御パラメータ等）: 入力取得直後にCRC計算→ASIL-Dコアへ。演算後に再検証
- 大量データ（画像等）: CRCは過剰。正常系の出力側チェックで対処、ASIL-Dコアでは出力plausibilityだけ

**制御フローの化け**: 毎フレームの状態変数をASIL-Dコアに送り、遷移テーブルで正当性検証。転送はE2Eプロテクション。

**チェック機構自体の故障**:

- チェック用定数テーブル: 起動時にCRC計算してASIL-Dコアで保持。毎フレーム再計算して一致確認
- チェック結果フラグ: 符号化（正常=0xA5A5, 異常=0x5A5A）で1ビット反転耐性
- チェック実行の証明: シグネチャ方式（各チェックポイントで固有定数をXOR/CRC畳み込み）→ASIL-Dコアへ。スキップ・順序入れ替えを検出

### 4.3 残留リスク

故障検出の2段構成:

- 正常系の入出力の故障 → 正常系（ASIL-Bコア）の仕様チェックが検出
- 仕様チェック機構の故障 → 異常系（ASIL-Dコア）が検出

独立した実行環境なので自己参照問題は構造的に解消。

ただし、ASIL-Dコアに送る情報（CRC、シグネチャ等）を**生成する処理自体**がASIL-Bコア上で動いている。この生成処理がHW故障で壊れるケースが残留リスク。

#### シナリオ1: CRC計算過程のレジスタ化け

```
ASIL-Bコア:
  1. チェック定数 MAX_SAFE_VALUE が 100→50000 に化ける（故障A）
  2. 化けた定数のCRCを計算
     → CRC計算中にレジスタが化けて、偶然「元の正しいCRC値」が出る（故障B）
  3. ASIL-Dコアへ送信: {チェック結果=正常, CRC=正しい値}

ASIL-Dコア:
  CRCが起動時の値と一致 → 異常なしと誤判定
```

故障Aで閾値が化けて本来異常な出力がチェック通過 + 故障BでCRCも正常に見える → 検出漏れ

#### シナリオ2: チェックスキップ後のシグネチャ化け

```
ASIL-Bコア:
  1. アルゴリズム実行
  2. 出力チェックが制御フロー化けでスキップ（故障A）
  3. シグネチャはチェックポイント分の畳み込みが欠けた不正値
  4. この不正シグネチャが送信前にメモリ上で化けて偶然期待値に一致（故障B）

ASIL-Dコア:
  シグネチャ一致 → 異常なしと誤判定
```

#### なぜ問題にならないか

どちらも**複数の独立故障がFTTI内に同時発生**する必要がある。

**シナリオ1**: 故障A（定数のビットフリップ）と故障B（CRC計算中のレジスタ化け）は独立事象。さらに故障Bは単にCRC計算が壊れるだけでは駄目で、化けた定数に対して**偶然正しいCRC値を生成**しないといけない。CRC-32なら確率約2⁻³²（2.3×10⁻¹⁰）。同時発生確率はFIT rateの積で、ASIL-D目標値（10⁻⁸/h = 10 FIT）を大幅に下回る。

**シナリオ2**: 故障A（チェックスキップ）でシグネチャは確実に期待値と異なる。検出を逃れるには故障B（メモリ上のビットフリップ）で偶然期待値に一致する必要。32-bitシグネチャで約2⁻³²。

→ **無限に再帰的な保護は不要**。正常系/異常系の2段構成でISO 26262のdual-point fault枠組みとして定量的に十分。具体的な数値はHWのSERとCRC/シグネチャのビット幅から算出。

### 4.4 設計段階での導出フロー

正常系の実装完了を待たず、以下のSWアーキテクチャアーティファクトから導出できる。

```
SW Architecture設計
  │
  ├─ 入力インターフェース定義
  │    → 型・性質（スカラー/大量データ、ノイズ耐性）
  │    → 保護戦略の決定（CRC / E2E / 出力側チェックのみ / 不要）
  │
  ├─ 出力仕様定義
  │    → 値域・制約条件・物理的整合性条件
  │    → ASIL-Dコアの独立plausibilityチェック条件
  │
  ├─ 仕様チェックアルゴリズム定義
  │    → チェックに使う定数・閾値 → 定数CRC検証
  │    → 判定出力形式 → 符号化方式
  │    → 実行フロー → シグネチャ設計
  │
  └─ 状態遷移設計
       → 許可される遷移テーブル → ASIL-Dコアの遷移検証ロジック
```

どこにも正常系のアルゴリズム実装の詳細は不要。

---

## 5. 必要な研究

### 5.1 理論1: 仕様チェック構造→異常系モニタ要件の自動導出規則

正常系の仕様チェック構造を分析して、HW故障に対する検出不能パターンを特定し、ASIL-Dコアの監視項目を機械的に導出する変換規則を作りたい。

マッピングの体系化:

| 正常系の設計アーティファクト | 故障パターン | 異常系で必要な処理 |
|---|---|---|
| レンジチェック（定数閾値使用） | 閾値定数のビットフリップ | 定数CRC検証 |
| 状態遷移に依存する処理 | 状態変数のビットフリップ | 遷移テーブル検証 |
| 複数チェックの逐次実行 | 制御フロー化け（チェックスキップ） | シグネチャ実行証明 |
| チェック結果のbool出力 | 結果フラグのビットフリップ | 符号化結果値の検証 |
| スカラー入力に基づく演算 | 入力データのビットフリップ | 入力CRC検証 |
| 大量データ入力（画像等） | 入力データのビットフリップ | 出力側plausibility（正常系で吸収） |

### 5.2 理論2: SW仕様チェックのDCの設計時解析的評価

実装前に、仕様チェックの構造と故障モデルからDCを保守的に見積もる手法。

- N-bit出力にレンジチェック（許容範囲=全値域のR%）→ 1ビットフリップSDC検出率 ≥ (1 - R/100)
- M個のチェック定数にCRC-32 → 定数化け検出率 (1 - 2⁻³²) ≈ 1 - 2.3×10⁻¹⁰
- シグネチャ方式（K個のチェックポイント、W-bitシグネチャ）のスキップ検出率

ISO 26262のSPFM/LFMメトリクスに接続する形で定式化。

#### Availability観点: false positive率の評価

今回の構成は「正常系で仕様チェック＋異常系でメタチェック」なので、異常系で直接仕様チェックする場合と比べて故障判定要因が増える。故障がないのにメタチェック側で誤検出してspurious shutdownになるパスが複数ある:

- **定数CRC計算中のビットフリップ**: 正常な定数に対してCRC計算中にレジスタが化けて不正CRCが生成される → 定数化けと誤判定
- **シグネチャ計算中のビットフリップ**: 正しくチェックが実行されたのにシグネチャ畳み込み中に化けて不正シグネチャ → チェックスキップと誤判定
- **転送中のビットフリップ**: チェック結果・CRC・シグネチャがASIL-Dコアへの送信中に化ける
- **符号化結果フラグの化け**: 0xA5A5（正常）が0xA5A5でも0x5A5A（異常）でもない値に化ける → 異常と誤判定

各メカニズムのfalse positive率は独立に計算できる:

- 定数CRC: CRC計算に関与するレジスタ数 × ビット幅 × SER × 計算時間
- シグネチャ: 畳み込み処理のレジスタ数 × ビット幅 × SER × 計算時間（チェックポイント数が多いほど増加）
- 転送: 送信データのビット数 × メモリ/バスのSER × 滞在時間
- 符号化フラグ: フラグのビット数 × SER × 滞在時間

全体のfalse positive率 = 1 - (1-p₁)(1-p₂)(1-p₃)(1-p₄)。各pᵢが極めて小さい（10⁻¹⁰以下）ので ≈ p₁ + p₂ + p₃ + p₄ で近似可。これにチェック頻度（毎フレーム、数ms周期等）を掛けると時間あたりのspurious shutdown率が出る。

通常は各メカニズム個別のfalse positive率はかなり低いが、チェック頻度が高いと累積で無視できなくなる可能性がある。

設計時に評価すべきトレードオフは、アーキテクチャの選択によって異なる:

- **今回の構成（正常系で仕様チェック＋異常系でメタチェック）**: DC（検出率）とfalse positive率のトレードオフ。メタチェック項目を増やすとDCは上がるがfalse positive率も上がる
- **異常系（ASIL-Dコア）で仕様チェックを直接行う構成**: false positive率の問題は消えるが、DC（検出率）と実行速度のトレードオフが生まれる。ASIL-Dコアの処理能力は正常系より限られる場合が多く、チェック項目を増やすとFTTI内に処理が収まらなくなる可能性がある

どちらの構成を選ぶかの判断にも、これらのトレードオフの事前定量評価が必要。

### 5.3 理論3: 統合メソドロジー

理論1と2を統合して、SWアーキテクチャ設計から異常系処理仕様を一気通貫で導出するフレームワーク。

- **V-model左側（設計）**: 入力定義・出力仕様・チェックアルゴリズム・状態遷移から異常系を導出、DC設計時見積もり、false positive率評価
- **V-model右側（検証）**: 正常系実装完了後、形式検証（Arcanum等）やフォールトインジェクションでDC見積もりとfalse positive率の妥当性確認

---

## 6. 先行研究

### 6.1 安全要件からのランタイムモニタ合成

**Heffernan et al. (IET Software, 2014)**: ISO 26262安全要件→past-time LTL式→FPGAモニタ回路の自動合成。著者ら自身「この概念はまだ十分に探求されていない」と言っている。→ モニタ合成の枠組みは参考になるが、HW一過性故障の故障モデルを考慮したモニタ導出ではない

**ESC-QC (IEEE, 2011)**: イベントシーケンスチャート＋量的制約→Simulink/Stateflowモニタ自動合成。→ 仕様→モニタの自動変換パイプラインは参考。ただし故障モデルに基づく導出ではない

**Runtime Monitoring for AVs (MDPI Electronics, 2025)**: 制御された自然言語→LTL形式仕様→ランタイムモニタ。→ 安全要件→形式仕様→モニタの段階的導出プロセスは参考

**BTC EmbeddedSpecifier**: 産業ツール。安全要件→半形式的/形式的記法→モデル検査モニタ合成。TÜV SÜD認証ASIL D対応。Simulinkモデル上での仕様検証が主眼。→ 形式仕様からの自動検証は参考。HW故障考慮の異常系導出は範囲外

### 6.2 安全パターン

**Safety Pattern Synthesis (AutoFOCUS3)**: システムアーキテクチャ中の故障に対する安全パターンの自動推薦。ロジックプログラミングバックエンド。→ 自動推薦の仕組みは参考だが、「仕様チェック構造→モニタ要件」の規則は無い

**USF (Universal Safety Format)**: 安全メカニズムを言語非依存な変換言語で記述。パターン再利用性向上。→ 記述形式は参考

**AUTOSAR WdgM**: 設計フェーズで有効なプログラムシーケンスをモデル化、ランタイムでチェックポイントベース監視。→ シグネチャ方式と直接対応。ただしWdgMは出力plausibilityやデータ完全性はスコープ外

**Safety Patterns (Bitsch 2001, Konrad et al.)**: 86パターンを19クラスに分類したカタログ。→ パターン体系化手法は参考。HW故障モデルとの対応づけは無い

### 6.3 設計段階でのDC評価

**FMEDA**: ISO 26262 Part 5のHW定量安全分析。DC = High(99%)/Medium(90%)/Low(60%)。SPFM, LFM, PMHF算出。→ HWのDC評価フレームワークは参考モデルだが、SW仕様チェックのDC評価には直接使えてない。DC推定方法の参考資料が不足してる点も報告あり

**Safety-Oriented HW Exploration (MDPI, 2022)**: 故障木ベース脆弱性分析＋HWアーキテクチャ探索→FMEDAレポート自動生成。→ 設計段階でのFMEDA自動化手法は参考

**Cone of Influence (Mentor/Siemens)**: RTLレベル構造解析で安全メカニズムの有効性を定量化→推定DC算出。→ HW RTLの設計時DC評価。これをSW仕様レベルに拡張する方向性

**Safety Synthesis (Mentor/Siemens)**: 設計構造に安全メカニズムを自動挿入。レジスタレベル＋モジュールレベル。→ HW設計での自動挿入の考え方をSW設計に応用する方向性

### 6.4 その他

**AVF (Mukherjee et al., MICRO 2003)**: ビットフリップが出力エラーに至る確率をHW構造ごとに定量化。ACEビット概念。→ 故障影響度の定量化の基本概念。ただしボトムアップ（実装後）解析。V-model右側での検証にAVF的解析が使える

**PVF (Sridharan & Kaeli, ISCA 2010)**: AVFをSW側に拡張。マイクロアーキテクチャ非依存な命令レベル脆弱性定量化。→ V-model右側の検証手法として参考

**AUTOSAR E2E Protection Library**: 通信データのEnd-to-End保護（CRC、Counter、DataID等）。→ 入出力データの転送時保護として直接使える

---

## 7. 研究ギャップまとめ

| 必要な理論 | 既存の到達点 | ギャップ |
|---|---|---|
| **仕様チェック構造→異常系モニタ自動導出** | 安全要件→モニタ合成（Heffernan, ESC-QC）、安全パターンカタログ（Bitsch, USF）、WdgM | 「仕様チェック構造」＋「HW故障モデル」→検出不能パターン特定→異常系モニタ要件自動導出、という変換規則が無い |
| **SW仕様チェックDCの設計時解析的評価** | FMEDA（HW向け）、Cone of Influence（RTL向け）、DC推定表（ISO 26262-5 Annex D） | SWのレンジチェック・plausibility等のDCを実装前に故障モデルから解析的に見積もる手法が無い |
| **統合メソドロジー** | 個々の要素技術（E2E, WdgM, Safety Pattern, FMEDA）は存在 | 「SWアーキテクチャ設計→故障パターン分析→異常系処理仕様→DC見積もり」の一気通貫フレームワークが無い |

### 新規性

1. **故障モデル駆動の異常系設計**: 既存研究は何を監視すべきか人間が安全分析から決める。ここでは仕様チェック構造＋HW故障モデルから検出不能パターンを形式的に分析して異常系を自動導出する
2. **設計段階で完結**: AVF/PVFは実装後ボトムアップ。正常系の実装を待たずSWアーキテクチャ設計段階で異常系を確定できる
3. **SW仕様チェックDC評価の理論化**: FMEDAのDC評価をSW仕様チェックに拡張する理論は存在しない。レンジチェックのSDC検出率等の解析モデルは新規
